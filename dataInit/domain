什么是领域模型？
领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过对象模型来实现，这些对象
同时包含了数据和行为，并且表达了准确的业务含义。

常见的问题：
接口业务意图不明确，实现本身增加了潜在的复杂性，领域对象只是一个数据持有器

"注射流感疫苗"的最佳模型：
"谁管呢？写代码就行了。":patient.setShotType(ShotTypes.TYPE_FLU);patient.setDose(dose);patient.setNurse(nurse);
"我们给病人注射流感疫苗。":patient.giveFluShot();
"护士给病人注射标准剂量的流感疫苗。":
Vaccine vaccine = vaccines.standardAdultFluDose();
nurse.administerFluVaccine(patient,vaccine);这才是我们想要的。


一个简单的案例：
需求：允许将每一个待订项提交到冲刺中。只有在一个待定项位于发布计划(Release)中时才能进行
提交。如果一个待定项已经提交到了另外一个冲刺中，那么需要先将其回收。提交完成时，通知相关
客户方。
public class BacklogItem extends Entity{
    private SprintId sprintId;
    private BacklogItemStatusType status;
    ...
    public void commitTo(Sprint aSprint){
        if(!this.isScheduledForRelease()){
            throw new IllegalStateException("must be scheduled for release to commit to sprint");
        }
        if(!this.isCommittedToSprint()){
            if(!aSprint.sprintId().equals(this.sprintId())){
                this.uncommitFromSprint();
            }
        }
        this.elevateStatuWith(BacklogItemStatus.COMMITTED);
        this.setSprintId(aSprint.sprintId());
        DomainEventPublisher.instance().publish(new BacklogItemCommitted(this.tenant(),this.backlogItemId(),this.sprintId()));
    }
    ...
}
此时的客户端代码如下：
backlogItem.commitTo(sprint);


SaaSOvation,它的产品对DDD的使用
CollabOvation这是一套企业协作软件，并且加入了社交网络的功能。该产品的功能包括论坛，共享日历，博客，即时消息，
留言板，文档管理，通知和提醒，活动跟踪和RSS等。
ProjectOvation主要用于敏捷项目的管理，使用Scrum作为项目管理方式，并且采用增量式的管理框架。该产品采用传统的Scrum
项目管理模型，包括产品，产品负责人，团队，待定项，计划发布和冲刺。



领域，子域，限界上下文
从广义上讲，领域即是一个组织所做的事情以及其中所包含的一切。

限界上下文是一个显示的边界，领域模型便存在于这个边界之内。领域模型是把通用语言表达成软件模型。
限界上下文主要是一个语义上的边界

领域中还同时存在问题空间和解决方案空间。在问题空间中，我们思考的是业务面临的挑战，而在
解决方案空间中，我们思考如何实现软件以解决这些业务挑战。


上下文映射图主要帮助我们从解决方案空间的角度看待问题。

处理资源不可用的一个好办法便是将器显现出来。考虑一下由标准类型实现的状态模式。此时的状态是一个值对象：
public enum DiscussionAvailability{
    ADD_ON_NOT_ENABLED,NOT_REQUESTED,REQUESTED,READY;
}
public final class Discussion implements Serializable{
    private DiscussionAvailability availability;
    private DiscussionDescriptor descriptor;
    ...
}
public class Product extends Entity{
    ...
    private Discussion discussion;
    ...
}

命令处理器通常只完成有限的功能。如果处理器拥有创建功能，那么它会创建一个新的聚合实例，然后
将该实例添加到资源库中。通常地，命令处理器将从源库中获取聚合实例，再调用该实例的行为方法：
@Transaction
public void commitBacklogItemToSprint(String aTenantId,String aBacklogItemId,String aSprintId){
    TenantId tenantId = new TenantId(aTenantId);
    BacklogItem backlogItem = backlogItemRepository.backlogItemOfId(tenantId,new BacklogItemId(aBacklogItemId));
    Sprint sprint = sprintRepository.sprintOfId(tenantId,new SprintId(aSprintId));
    backlogItem.commitTo(sprint);
}
命令模型（写模型）执行业务行为
命令模型上每个方法在执行完成时都将发布领域事件。以BacklogItem为例：
public class BacklogItem extends ConcurrencySafeEntity{
    ...
    public void commitTo(Sprint sprint){
        ...
        DomainEventPublisher.instance().publish(new BacklogItemCommitted(this.tenant(),this.backlogItemId(),this.sprintID()));
    }
    ...
}


事件驱动架构
事件驱动架构是一种用于处理事件的生成、发现和处理等任务的软件框架
基于消息的系统通常呈现出一种管道和过滤器风格。cat phone_numbers.txt | grep '303' | wc -l
如何通过创建消息发送方和接收方这样的组件来完成上例中电话号码过滤功能？
1.PhoneNumbersPublisher读取数据，发送AllPhoneNumbersListed事件
2.PhoneNumberFinder接收，发送PhoneNumberMatched事件
3.MatchPhoneNumberCounter接收，发送MatchedPhoneNumbersCounted事件
4.PhoneNumberExecutive接收，记录日志

分布式的并行处理模式--长时处理过程（Long-Running Process）
设计长时处理过程的不同方法
1.将处理过程设计成一个组合任务，使用一个执行组件对任务进行跟踪，并对各个步骤和任务完成情况精心持久化。
2.将处理过程设计成一组聚合，这些聚合在一些列的活动中相互协作。一个或多个聚合实例充当执行组件并维护整个处理过程的状态。
3.设计一个无状态的处理过程，其中每一个消息处理组件都将对所接收到的消息进行扩充--即向其中计入额外的数据信息--然后再将消息发送到下一个处理组件
此时并行处理长时处理过程存在一个问题，无法知道所接收到的领域事件是否来自统一并行处理过程？
在实际领域中，一个长时处理过程的执行器将创建一个新的类似聚合的状态对象来跟踪事前的完成情况。该状态
对象在处理过程开始时创建，它将与所有的领域事件共享一个唯一标识。同时，将处理过程开始时的时间戳保存在该状态对象中也是有好处的。

接下来看看一个实现了长时处理过程的函数是如何处理先前的电话号码例子的。这个处理过程将在复制缓存中并行执行，使用的是GemFire函数：
public class PhoneNumberCountSaga extends FunctionAdapter{
    @Override
    public void execute(FunctionContext context){
        Cache cache = CacheFactory.getAnyInstance();
        QueryService queryService = cache.getQueryService();
        String phoneNumberFilterQuery = (String)context.getArguments();
        ...
        //伪代码
        //-执行函数以获取MatchedPhoneNumbersCounted
        //-通过调用aggregator.sendResult(MatchedPhoneNumbersCounted)将答案发给聚合器
        //-执行函数以获取AllPhoneNumbersCounted
        //-通过调用aggregator.sendResult(AllPhoneNumbersCounted)将答案发给聚合器
        //-聚合器从每个分布式的函数返回中自动地收集答案，然后聚合
        //之后的单一答案发送给客户端
    }
}
客户端可以通过以下方式来并行地执行一个长时处理过程:
PhoneNumberCountProcess phoneNumberCountProcess = new PhoneNumberCountProcess();
String phoneNumberFilterQuery = "select phoneNumber from phoneNumberRegion pnr where pnr.areaCode = '303'";
Execution execution = FunctionService.onRegion(phoneNumberRegion).withFilter(0).withArgs(phoneNumberFilterQuery).withCollection(new PhoneNumberCountResultCollector());
PhoneNumberCountResultCollector resultsCollector = execution.execute(phoneNumberCountProcess);
List allPhoneNumberCountResults = (List)resultsCollector.getResult();

为什么使用实体
当需要考虑一个对象的个性特征，或者需要区分不同的对象时，引入实体这个领域概念。




